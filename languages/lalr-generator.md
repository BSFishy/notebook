# lalr generator

okay so i blabbered to chatgpt for i dont even know how long at this point. we
were on parser combinators for a while but looped back on lalr parsers.
basically that's the type of parser generated by tools like antlr. we get things
like left recursion for free AND it sounds like its like the go to for optimized
parsers. so of course thats the goal.

the idea is to provide a generic api for parsers. i want to specify a grammar,
and it provides me with a function to turn input into an ast. need to figure out
if i need to tokenize first but regardless it scales to infinity for like free,
ie insanely huge input file sizes. further, if i do it right, errors should be
super good and it should also be able to recover from errors pretty well.

so all in all im basically looking to reimplement antlr. but in zig comptime.
yea we'll see about that. so the major thing is that i wont be needing to like
parse an entirely separate language to generate the tables. ill just be
specifying the actual data extracted from the file representation to then go and
generate the tables. so maybe a little easier ideally?

lalr works with jump tables. its a state machine that tracks the current state
and the current token. it looks that up in a table (state, token) which maps to
an action. one of shift, reduce, accept, error. it then looks up (state,
non-terminal) to get the next state. so it is literally 1-1 linear scaling input
to new state. incredible perfect scaling for a parser.

so shifting is pushing the token onto a stack and move to the next state. reduce
will pop a number of tokens off the stack, apply a grammar rule, and push the
result. accept is for when parsing is complete. error is when a token is
unexpected, report an error. i believe in this state, we could also search the
table for the current state to get a list of tokens that were expected.

all in all, all i really need to do is take a grammar definition and produce a
few tables. ideally i also generate a type for the output that is fully typed
and wonderful and incredible and great so that i get full type safety and all
that out of the parser. we'll have to see how much zls likes it but whatever i
can figure it out.

sounds like there are a few pitfalls i'll need to watch out for like conflict
resolution for shift/reduce and reduce/reduce conflicts during table gen. also
error recovery may be a little difficult but we'll see if i even do that. table
sizes will also probably need to be deduped so they don't get too big.

all in all, i'll need to do more research on lalr parsers, but this sounds like
the way to go for building my unified parser api. i dont every want to have to
think about or worry about building parsers again. it should be trivial and i
should get exactly what i want because software _can_ be good.
